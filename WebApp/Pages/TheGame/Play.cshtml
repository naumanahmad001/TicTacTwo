@page
@model WebApp.Pages.TheGame.PlayModel
@{
    Layout = "_Layout";
}

<style>
    #grid.disabled {
        pointer-events: none;
        opacity: 0.5;
    }
</style>
<script src="~/lib/jquery/dist/jquery.min.js"></script>
<div class="container d-flex flex-column justify-content-center align-items-center text-center">
    <!-- Title -->
    <h1 class="mb-4">Tic Tac Two - @Model.GameName</h1>
    <input type="hidden" id="gameName" value="@Model.GameName" />
    <!-- Grid Section -->
    <div> You are playing as: @Model.MyPiece</div>
    <div id="grid" class="grid mb-4"></div>

    <!-- Controls Section -->
    <div class="controls text-center my-4">
        <div class="row justify-content-center">
            <!-- Move Up Button -->
            <div class="col-12 mb-2">
                <button id="move-up" class="btn btn-primary btn-lg">
                    <i class="fas fa-arrow-up"></i>
                </button>
            </div>
            <!-- Left, Reset, Right Buttons -->
            <div class="col-12 d-flex justify-content-center">
                <button id="move-left" class="btn btn-primary btn-lg me-2">
                    <i class="fas fa-arrow-left"></i>
                </button>
                <button id="reset-game" class="btn btn-danger btn-lg mx-2">
                    <i class="fas fa-sync-alt"></i>
                </button>
                <button id="move-right" class="btn btn-primary btn-lg ms-2">
                    <i class="fas fa-arrow-right"></i>
                </button>
            </div>
            <!-- Move Down Button -->
            <div class="col-12 mt-2">
                <button id="move-down" class="btn btn-primary btn-lg">
                    <i class="fas fa-arrow-down"></i>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Winning Modal -->
<div class="modal fade" id="winningModal" tabindex="-1" aria-labelledby="winningModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-success text-white">
                <h5 class="modal-title" id="winningModalLabel">Congratulations!</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body text-center">
                <h3 id="winner-message" class="mb-4"></h3>
                <!-- Fireworks Container -->
                <div id="fireworks-container" style="position: relative; height: 200px; overflow: hidden;">
                    <!-- Fireworks will appear here -->
                </div>
            </div>
            <div class="modal-footer justify-content-center">
                <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Play Again</button>
            </div>
        </div>
    </div>
</div>



<script>
    $(document).ready(function () {
        // Inject values from backend36
        const savedPieces = @Html.Raw(Json.Serialize(Model.SavedPieces));
        const config = @Html.Raw(Json.Serialize(Model.GameConfig)); // Inject game config into JS
        const isNewGame = @Model.IsNewGame.ToString().ToLower(); // Check if the game is new or loaded
        const boardSize = config.boardSize;        // Overall grid size
        const gridSize = config.gridSize;         // Smaller matrix size
        const playerSymbols = [config.playerOnePiece, config.playerTwoPiece];
        const myPiece = '@Model.MyPiece.ToString()';
        let currentPlayer = 0;                   // Start with player 1
       

        // Initialize the grid
        const $grid = $('#grid');
        $grid.css({
            'grid-template-columns': `repeat(${boardSize}, 1fr)`,
            'grid-template-rows': `repeat(${boardSize}, 1fr)`,
        });

        // Generate the grid dynamically
        for (let i = 0; i < boardSize; i++) {
            for (let j = 0; j < boardSize; j++) {
                const $cell = $('<div class="cell" data-row="' + i + '" data-col="' + j + '"></div>');
                $grid.append($cell);
            }
        }

        // Highlight active matrix
        function highlightMatrix() {
            $('.cell').removeClass('active');
            for (let i = matrixStartRow; i < matrixStartRow + gridSize; i++) {
                for (let j = matrixStartCol; j < matrixStartCol + gridSize; j++) {
                    $('[data-row="' + i + '"][data-col="' + j + '"]').addClass('active');
                }
            }
        }
        function updateGridStatus() {
            if (playerSymbols[currentPlayer] === myPiece) {
                $grid.removeClass('disabled');
            } else {
                $grid.addClass('disabled');
            }
        }
        // Place saved pieces if the game is loaded
        //if (!isNewGame) 
        {
            // Place saved pieces on the grid
            Object.keys(savedPieces).forEach(key => {
                const [row, col] = key.split(',').map(Number); // Parse the string key back into row, col
                const symbol = savedPieces[key];

                // Find the corresponding cell and set the symbol
                const $cell = $(`[data-row='${row}'][data-col='${col}']`);
                $cell.text(symbol).addClass('taken');
            });
        }

        // Validate if move is valid
        function isValidMove(rowOffset, colOffset) {
            const newRowStart = matrixStartRow + rowOffset;
            const newColStart = matrixStartCol + colOffset;
            return (
                newRowStart >= 0 &&
                newColStart >= 0 &&
                newRowStart + gridSize <= boardSize &&
                newColStart + gridSize <= boardSize
            );
        }

        // Move matrix
        function moveMatrix(rowOffset, colOffset) {
            if (isValidMove(rowOffset, colOffset)) {
                matrixStartRow += rowOffset;
                matrixStartCol += colOffset;
                highlightMatrix();
            }
        }

        // Handle cell clicks
        $('.cell').on('click', function () {
            if ($grid.hasClass('disabled')) return;

            const $cell = $(this);
            if ($cell.hasClass('active') && !$cell.hasClass('taken')) {
                $cell.text(myPiece).addClass('taken');

                // Save move and notify server
                const positions = {};
                $('.cell.taken').each(function () {
                    const row = $(this).data('row');
                    const col = $(this).data('col');
                    const text = $(this).text();
                    positions[`${row},${col}`] = text;
                });

                const nextPlayer = (currentPlayer + 1) % 2; // Switch player
                saveGameStateToServer(positions, nextPlayer);

                currentPlayer = nextPlayer; // Update locally
                updateGridStatus(); // Disable grid for this player
            }
        });

        // Reset Game Functionality
        $('#reset-game').on('click', function () {
            $('.cell').text('')                 // Clear all cell text
                .removeClass('taken');          // Remove 'taken' class
            currentPlayer = 0;                  // Reset to player 1
            matrixStartRow = 0;                 // Reset matrix position
            matrixStartCol = 0;
            highlightMatrix();                  // Re-highlight matrix
        });

        // Movement buttons
        $('#move-up').on('click', function () {
            moveMatrix(-1, 0);
        });
        $('#move-down').on('click', function () {
            moveMatrix(1, 0);
        });
        $('#move-left').on('click', function () {
            moveMatrix(0, -1);
        });
        $('#move-right').on('click', function () {
            moveMatrix(0, 1);
        });

        // Initial matrix highlight
        highlightMatrix();

        // Check win conditions
        function checkWin() {
            const symbol = playerSymbols[currentPlayer];
            let win = false;

            // Check rows and columns within the active matrix
            for (let i = 0; i < gridSize; i++) {
                let rowWin = true, colWin = true;

                for (let j = 0; j < gridSize; j++) {
                    const rowCell = $('[data-row="' + (matrixStartRow + i) + '"][data-col="' + (matrixStartCol + j) + '"]');
                    const colCell = $('[data-row="' + (matrixStartRow + j) + '"][data-col="' + (matrixStartCol + i) + '"]');

                    if (rowCell.text() !== symbol) rowWin = false;
                    if (colCell.text() !== symbol) colWin = false;
                }

                if (rowWin || colWin) {
                    win = true;
                    break;
                }
            }

            // Check diagonals
            let diag1Win = true, diag2Win = true;
            for (let i = 0; i < gridSize; i++) {
                const diag1Cell = $('[data-row="' + (matrixStartRow + i) + '"][data-col="' + (matrixStartCol + i) + '"]');
                const diag2Cell = $('[data-row="' + (matrixStartRow + i) + '"][data-col="' + (matrixStartCol + gridSize - 1 - i) + '"]');

                if (diag1Cell.text() !== symbol) diag1Win = false;
                if (diag2Cell.text() !== symbol) diag2Win = false;
            }

            if (diag1Win || diag2Win) win = true;

            // If there's a win, announce it and reset
            if (win) {
                showWinningModal(currentPlayer, symbol);
                $('#reset-game').trigger('click');
            }
        }

        // Save game state to server
        

        // Show winning modal
        function showWinningModal(winningPlayer, symbol) {
            $("#winner-message").html(`🎉 Player ${winningPlayer + 1} (${symbol}) wins! 🎉`);
            $("#winningModal").modal("show");
        }
    });
</script>

